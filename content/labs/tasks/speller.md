# Speller

### Набір файлів для лабораторної роботи

#### Завантаження

```bash
$ wget http://cdn.cs50.net/2017/fall/psets/5/speller.zip
$ unzip speller.zip
$ rm speller.zip
$ cd speller
$ ls
dictionaries/  dictionary.c  dictionary.h  keys/  Makefile  README.md speller.c  texts/
```

#### Розуміння

Теоретично, на вхідних даних розміру *n*, алгоритм із часом виконання *n* асимптотично еквівалентний в термінах *O*-нотації до алгоритму з часом виконання *2n*. У реальному світі ж, насправді, другий алгоритм виконується вдвічі повільніше від першого.

Ваша задача - реалізувати якомога більш швидку програму для перевірки орфографії! Коли ми говоримо про якомога більш швидку програму, ми маємо на увазі таку, що буде найшвидше виконуватись у термінах реального часу, а не в термінах асимптотики.

У файлі `speller.c` знаходиться програма, яка створена для перевірки орфографії у файлі після завантаження словника із диску до пам'яті. Нажаль, у нас так і не дійшли руки реалізувати частину із завантаженням файлу, як і частину із перевіркою орфографії. Обидві задачі (і навіть трохи більше) ми залишили для вас! Але спочатку, введення.

#### dictionary.{c,h}

Відкрийте файл `dictionary.h`. У ньому оголошено чотири функції; зрозумійте, що має робити кожна з них. Тепер відкрийте файл `dictionary.c`. Зверніть увагу, що ми реалізували ці чотири функції, але зовсім трошки - лише для того, щоб код компілювався. Ваша задача, в кінці кінців, заново реалізувати ці функції якомога розумніше для того, щоб програма по перевірці грамотності працювала, як було обіцяно. І робила це швидко!

#### Makefile

Пригадайте, що `make` автоматизує компіляцію вашого коду, щоб вам не потрібно було самостійно викликати `clang` разом із купою прапорців. Однак, коли ваші програми ставатимуть більшими, `make` не зможе розуміти як компілювати ваш код; вам потрібно буде почати говорити `make`,як йому компілювати вашу програму, особливо у тих випадках, коли вона складається з декількох файлів із кодом (C файлів), як у випадку з цією задачею. І тому ми використаємо `Makefile`, конфігураційний файл, який говорить `make`, що саме йому потрібно робити.  Відкрийте `Makefile`, і давайте подивимось, що всередині.

Рядок нижче визначає змінну на ім’я `CC` яка показує що `make` має використовувати `clang` для компіляції.

```
CC = clang
```

Наступний рядок визначає змінну `CFLAGS`, яка, у свою чергу, визначає прапорці, які має використати `clang`; більшість з них повинні бути вам знайомі.

```
CFLAGS = -fsanitize=integer -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wshadow
```

Наступний рядок визначає змінну `EXE`, значення якої буде ім’ям нашої програми.

```
EXE = speller
```

Наступний рядок визначає змінну `HDRS`, значення якої – список файлів заголовку, що використовує `speller`, розділений пробілами.

```
HDRS = dictionary.h
```

Наступний рядок визначає змінну `LIBS`, значення якої – розділений пробілами список заголовних бібліотек, кожній з яких має передувати `-l` (Пригадайте використання `-lcs50` раніше.) Швидше за все, вам не буде потрібна жодна бібліотека для цього завдання, але ми включили цю опцію про всяк випадок.

```
LIBS =
```

Наступний рядок визначає змінну `SRCS`, значення якої – розділений пробілами список С-файлів, які є реалізацією задачі `speller`.

```
SRCS = speller.c dictionary.c
```

Наступний рядок визначає змінну `OBJS`, значення якої те саме, що і `SRCS`, за винятком того, що розширенням файлів є не `.c`, а `.o`.

```
OBJS = $(SRCS:.c=.o)
```

Рядки, що наведені нижче, визначають "ціль" компіляції, із використанням змінних, що говорять `make`, як компілювати `speller`.

```
$(EXE): $(OBJS) Makefile
    $(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS)
```

Наступний рядок визначає, що наші `.o` файли залежать від `dictionary.h` і `Makefile`, тому зміни будь-якого з них приведуть до рекомпіляції `.o` файлів при наступному запуску `make`.

```
$(OBJS): $(HDRS) Makefile
```

Нарешті даний код визначає іншу ціль для очищення директорії цієї задачі

```
clean:
    rm -f core $(EXE) *.o
```

Тепер, коли ви знаєте призначення коду в `Makefile`, то  можете модифікувати його, як вважаєте за потрібне. Насправді, ви повинні його модифікувати, якщо будете створювати `.c` чи `.h` файли. Будьте уважні і не замініть будь-які знаки табуляції (`\t`) на пробіли, оскільки make очікує саме їх під кожною "ціллю".

Завдяки цим рядкам коду, ви можете скомпілювати `speller` однією командою, не дивлячись на те, що він складається з кількох файлів:

```bash
make speller
```

Більше того, можна просто виконати:

```bash
make
```

І якщо ви захочете видалити програму та будь-які `core` чи `.o`  файли, то можете це зробити однією командою:

```bash
make clean
```

Взагалі, для компіляції коду цього завдання достатньо наступної команди:

```bash
make
```

#### speller.c

Далі відкрийте `speller.c` і витратьте деякий час на перегляд коду та коментарів всередині. Вам не потрібно нічого змінювати в ньому, але ви все одно повинні розуміти його вміст. Подивіться, як за допомогою `getrusage` ми будемо вимірювати час виконання ваших реалізацій функцій `check`, `load`, `size`, і `unload`. Також зверніть увагу на те, як ми використовуємо `check`, передаючи йому, слово за словом, вміст файлу, правопис у якому потрібно перевірити. В кінці кінців, ми звітуємо про кожну помилку в тому файлі разом з деякою статистичною інформацією.

Крім того, зверніть увагу, що ми визначили використання `speller` як:

```
Usage: speller [dictionary] text
```

де `dictionary` – файл що містить список слів в нижньому регістрі, одне слово на рядок, а `text` – файл, вміст якого буде перевірено. Квадратні дужки означають, що надавати файл `dictionary` необов’язково; якщо даний аргумент пропущений, то `speller` використає `dictionaries/large` як словник за замовчуванням. Іншими словами запуск

```
./speller text
```

буде еквівалентним до

```
./speller dictionaries/large text
```

де `text` - це файл, який ви бажаєте перевірити. Варто сказати, що перший варіант легше набирати! (Звичайно `speller` не зможе завантажити будь-який словник доти, доки ви не реалізуєте `load` в `dictionary.c`! До цього ви будете бачити текст **Could not load**.)

Попереджуємо вас, що всередині словника за замовчуванням знаходяться 143091 слів, які повинні бути завантажені у пам’ять! Радимо глянути на вміст словника, щоб зрозуміти його структуру і розміри. Можна помітити, що кожне слово в цьому файлі записане в нижньому регістрі (навіть, для простоти, власні назви та абревіатури). Зверху вниз файл відсортований лексикографічно з одним словом на рядок (кожен з яких закінчується на `\n`). Всі слова є не довшими за 45 літер і зустрічаються у словнику лише раз. В процесі розробки може бути зручно надавати `speller` ваш власний `dictionary`, який містить менше слів, що значно полегшить пошук помилок, адже інакше вам доведеться працювати із гігантською структурою, завантаженою у пам'ять. Ви можете знайти такий словник у `dictionaries/small`. Для того, щоб його використати, виконайте:

```
./speller dictionaries/small text
```

де `text` - це файл який ви хочете перевірити. Не продовжуйте доти, доки ви не будете впевнені, що зрозуміли, як працює `speller`!

Скоріше за все ви витратили недостатньо часу, вивчаючи `speller.c`. Зробіть один крок назад і перегляньте його знову!

#### texts/

Для того, щоб ви могли перевірити вашу реалізацію `speller`, ми також надали вам багато різних текстів. Серед них є сценарій *La La Land*, текст *Закону про доступний медичний догляд*, три мільйони байтів, створених Толстим, деякі витяги із *Записок Федераліста* та Шекспіра, повний текст *біблії Королоя Якова V* і *корану* і т.д. Для того, щоб знати, чого очікувати, відкрийте і перегляньте кожен із цих файлів, всі з яких знаходяться у папці `texts`, що знаходиться у папці `pset5`.

Тепер, як ви можете знати, прочитавши код у `speller.c`, вивід `speller`, якщо його запустити з:

```
./speller texts/lalaland.txt
```

буде подібний до тексту що слідує. Спочатку спробуйте запустити рішення працівників CS50 (використавши словник за замовчуванням) за допомогою:

```
~cs50/pset5/speller texts/lalaland.txt
```

Нижче ви можете побачити витяги із виводу програми. Заради надання інформації, ми надаємо уривок деяких помилок написання. Щоб не зіпсувати ваше задоволення, ми поки що не показуватимемо статистику нашої програми.

```
MISSPELLED WORDS

[...]
AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
[...]
Shangri
[...]
fianc
[...]
Sebastian's
[...]

WORDS MISSPELLED:
WORDS IN DICTIONARY:
WORDS IN TEXT:
TIME IN load:
TIME IN check:
TIME IN size:
TIME IN unload:
TIME IN TOTAL:
```

`TIME IN load` – це час (у секундах) необхідний `speller` на виконання вашої реалізації `load`. `TIME IN check` - це час (у секундах) необхідний `speller` на виконання вашої реалізації `check`. `TIME IN size` - це час (у секундах) необхідний `speller` на виконання вашої реалізації `size`. `TIME IN unload` - це час (у секундах) необхідний `speller` на виконання вашої реалізації `unload`. `TIME IN TOTAL` – повний час виконання `speller` (сума 4-х попередніх значень).

**Зауваження: дані числа можуть змінюватись між двома послідовними викликами `speller`, залежно від того, що ще робить CS50 IDE, навіть якщо ви не змінювали свій код.**

Варто зауважити, що під «словами із помилками» ми розуміємо слова, яких немає в словнику `dictionary`, який був переданий при виконанні `speller`.

### Запитання

Відкрийте `README.md` і дайте відповідь на всі запитання, що там знаходяться.

### Специфікація

Що ж тепер ви маєте реалізувати `load`, `check`, `size`, і `unload` так ефективно, як це тільки можливо, щоб мінімізувати `TIME IN load`, `TIME IN check`, `TIME IN size` і `TIME IN unload`. Можливо, трохи не зрозуміло, що в даному контексті означає "мінімізувати", оскільки дані числа будуть змінюватись залежно від того, з яким словником і для якого тексту ви запустите `speller`. Однак це і є найскладніша і найвеселіша частини цієї задачі. Це ваш шанс придумати власний дизайн програми. Звичайно, ми запрошуємо вас мінімізувати використання пам’яті, але зараз вашим основним ворогом є мінімізація часу. Перед тим, як ви почнете - ось деякі специфікації від нас.

* Ви не можете змінювати `speller.c`.
* Ви можете змінювати `dictionary.c` (і повинні це зробити, щоб завершити  реалізацію `load`, `check`, `size`, і `unload`), але ви не можете змінювати *оголошення* `load`, `check`, `size` чи `unload`.
* Ви можете змінювати `dictionary.h`, але не можете змінювати оголошення `load`, `check`, `size`, чи `unload`.
* Ви можете змінювати `Makefile`.
* Ви можете додавати функції до `dictionary.c` чи інших файлів, які ви створите, при умові, що ваш код компілюється з `make`.
* Ваша реалізація check повинна бути не чутлива до регістру. Іншими словами, якщо `foo` є в словнику, то `check` повинен повернути `true` для будь-якого слова, що відрізняється від `foo` лише регістром символів. Будь-яке слово з списку `foo`, `foO`, `fOo`, `fOO`, `fOO`, `Foo`, `FoO`, `FOo`, `FOO` є коректним.
* Якщо забути про регістр, ваша реалізація `check` повинна повертати `true` лише для слів, які дійсно є в словнику. Будьте обачні і не повертайте `true` незалежно від словника для слів, які часто зустрічаються (наприклад `the`), щоб запобігти проблем якщо ми передамо вашій реалізації словник (`dictionary`) без них. Вам не потрібно повертати `true` для слів у присвійному відмінку, якщо вони відсутні у словнику. Наприклад, якщо у словнику є слово `foo`, але немає `foo's`, `check` має повернути `true` для `foo` і `false` для `foo's`. **Головне правило: повертати `true` лише для слів, що знаходяться у словнику без урахування регістру**.
* Ви можете вважати що `check` буде отримувати лише рядки з символами з алфавіту та/або апострофами.
* Ви можете вважати що будь-який словник, переданий вашій програмі, буде структурований так само, як наш: лексикографічно відсортований зверху вниз, одне слово у рядку, кожне з яких закінчується на `\n`. Також можете вважати що словник містить хоча б одне слово та жодне слово не буде довше за `LENGTH` (константа визначена у `dictionary.h`) символів. Крім того, жодне слово не з’явиться частіше одного разу і кожне слово складається лише з символів (букв алфавіту) у нижньому регістрі та апострофів. 
* Ваша програма перевірки правопису має обов’язково приймати текст, як вхідні дані, та додатково може приймати словник.  Незважаючи на те, що вам, можливо, захочеться попередньо обробити словник за замовчуванням, щоб визначити найкращу для нього хеш-функцію, ви не можете зберегти результати такої обробки на диск, щоб надалі завантажувати з диску в пам'ять для пришвидшення наступних викликів.
* Ви можете використовувати хеш-функції  з книжок чи Інтернету, якщо зазначите походження хеш-функції  яку ви використали у своєму коді. (Попередні два пункти **не означають** що ви повинні чи не повинні використовувати хеші для розв'язку задачі. У вас є повна свобода щодо вибору алгоритму розв'язання задачі - примітка перекладача)
* У вашій програмі не має бути витоків пам'яті (memory leaks).

Отже, готові?

1. Реалізуйте `load`.
2. Реалізуйте `check`.
3. Реалізуйте `size`.
4. Реалізуйте `unload`.

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?list=PLhQjrBD2T382vvokQIExRCKZq-q8PzSVz&v=u9-1U1Rgo1o)

Зверніть увагу, що там знаходиться не одне, а чотири відео!

### Підказки

Переконайтесь, що ви звільнили у `unload` всю пам'ять, що ви виділили у `load`! Згадайте, що `valgrind` є вашим найновішим найкращим другом. Знайте, що `valgrind` шукає витоки пам'яті тоді, коли ваша програма дійсно виконується, тому якщо ви хочете, щоб `valgrind` проаналізував `speller` у той час, коли він використовує певний `dictionary` і/або `text`, передавайте їх як аргументи командного рядка, як показано нижче. Найкраще за все використовувати невеликі словник і текст, інакше `valgrind` може виконуватись доволі довго.

```bash
valgrind ./speller texts/ralph.txt
```

Якщо ви використовуєте `valgrind`, не вказавши `text` для `speller`, ваші реалізації `load` і `unload` не будуть викликані (а отже - проаналізовані).

Якщо ви не знаєте, як інтерпретувати вивід `valgrind`, попросіть про допомогу `help50`:

```
help50 valgrind ./speller texts/ralph.txt
```

### Тестування

Як перевірити, чи ваша програма виводить неправильно написані слова і робить це коректно? Що ж, ви можете поглянути на відповіді, що знаходяться всередині папки `keys`, що знаходиться всередині папки `speller `. Наприклад, всередині `keys/lalaland.txt` знаходяться всі слова, які ваша програма має прийняти за неправильно написані у відповідному тексті.

Ще ви можете у одному вікні виконати вашу програму, як показано нижче:

```
./speller texts/lalaland.txt
```

Ви також можете виконати розв'язок працівників CS50 на тому ж самому тексті у іншому вікні, як показано нижче:

```
~cs50/pset5/speller texts/lalaland.txt
```

Після цього ви можете порівняти вивід у обох вікнах. Це може доволі швидко стати складною операцією. Тому ви можете захотіти "перенаправити" вивід цих програм до файлу за допомогою наступних команд:

```bash
./speller texts/lalaland.txt > student.txt
~cs50/pset5/speller texts/lalaland.txt > staff.txt
```

Після цього ви можете порівняти ці файли у одному вікні за допомогою програми `diff` (чи її аналогу), як показано нижче:

```
diff -y student.txt staff.txt
```

Альтернативно, для того, щоб зберегти час, ви можете просто порівняти вивід вашої програми (із урахуванням того, що ви перенаправили його до, наприклад, `student.txt`) із збереженною відповіддю. В такому випадку вам не потрібно виконувати розв'язок працівників CS50. Використовуйте таку команду:

```
diff -y student.txt keys/lalaland.txt
```

Якщо вивід вашої програми співпадає з виводом працівників CS50, `diff` виведе дві ідентичні колонки (за виключенням, мабуть часу виконання унизу). Якщо ж колонки відрізняються, знаки `>` і `|` покажуть вам, де саме вони відрізняються. Наприклад, якщо ви бачите:

```
MISSPELLED WORDS                                                MISSPELLED WORDS

TECHNO                                                          TECHNO
L                                                               L
                                                              > Thelonious
Prius                                                           Prius
                                                              > MIA
L                                                               L
```

це означає, що ваша програма (її вивід - зліва) не вважає, що `Thelonious` і `MIA` написані неправильно, хоча вивід працівників CS50 (справа) так вважає. Це можно зрозуміти по відсутності, скажімо, `Thelonious` у лівій колонці і її присутності у правій колонці.

#### Коректніcть

Для того, щоб перевірити ваш код вручну (ця перевірка не є повною!), виконайте наступну команду:

```bash
check50 cs50/2018/x/speller
```

Зверніть увагу, що `check50` буде також перевіряти наявність витоків пам'яті, тому обов'язково виконайте `valgrind`.

#### Стиль

Щоб перевірити стиль файлу `dictionary.c`, виконайте команду:

```bash
style50 dictionary.c
```

Якщо ви змінювали інші `.c` чи `.h` файли - виконайте аналогічну команду і для них.

### Розв'язок працівників CS50

Як оцінити, наскільки швидко (і правильно) працює ваш код? Що ж, як завжди, ви можете погратись із розв'язком працівників CS50, як показано нижче, і порівняти його вивід із вашим.

```bash
~cs50/pset5/speller texts/lalaland.txt
```