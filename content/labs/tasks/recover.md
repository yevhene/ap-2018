# Recover

### Вступ

В очікуванні цієї задачі ми провели останні кілька днів, переглядаючи фотографії, які були збережені моєю цифровою камерою в форматі JPEG на карті пам’яті. (ОК, можливо, що насправді ми провели останні кілька днів на Facebook замість цього.) На жаль, ми якось видалили їх усіх! На щастя, в комп'ютерному світі, "видалений", як правило, означає "забутий". Не зважаючи на те, що камера наполягає на тому, що карта пам’яті тепер є порожньою, ми впевнені, що це не зовсім правда. Дійсно, ми сподіваємось (ем, очікуємо!), що ви можете написати програму, яка відновить фото для нас!

Незважаючи на те, JPEG-формат є більш складним, ніж BMP, JPEG має "підписи", шаблони байтів, які відрізняють їх від інших форматів файлів. А саме, перші три байти JPEG-файлів є такими (від першого байту до третьго зліва направо):

```
0xff 0xd8 0xff
```

В той же час, четвертий байт дорівнює одному із байтів у списку: `0xe0`, `0xe1`, `0xe2`, `0xe3`, `0xe4`, `0xe5`, `0xe6`, `0xe7`, `0xe8`, `0xe9`, `0xea`, `0xeb`, `0xec`, `0xed`, `0xee`, `0xef`. Інакше кажучи, перші чотири біти четвертого байту дорівнюють `1110`.

Швидше за все, якщо ви знайдете один з цих шаблонів на диску, на якому зберігаються фотографії (наприклад, моя карта-пам’яті), вони покажуть початок JPEG-файлу. Звичайно, ви можете зіткнутися з цим на якомусь диску випадково, тому відновлення даних не є точною наукою.

На щастя, цифрові камери, як правило, безперервно зберігають фотографії на картах пам’яті, в результаті чого кожна фотографія зберігається відразу ж після того фото, яке було збережене раніше. Відповідно, початок JPEG-файлу зазвичай слідує одразу за кінцем іншого. Однак, зазвичай карти пам’яті ініціалізовані у файловій системі FAT, "розмір блоку" якої становить 512 байт (B). Наслідком цього є те, що камери записують дані на ці карти в одиницях по 512 B. Якщо фото має розмір 1 МБ (тобто 1 048 576 B), то за цим принципом воно займає 1048576 ÷ 512 = 2048 "блоки" на карті. Таку ж кількість блоків займе файл розміром на один байт менше (тобто 1 048 575 B)! Незайнятий простір на диску називається "провисаючим простором". Судові слідчі часто використовують цю особливість для знаходження залишків підозрілих даних.

Наслідком всіх цих деталей є те, що ви, як слідчий, можете написати програму, яка буде проходити по копії моєї карти пам’яті, шукаючи підписи (сигнатури) JPEG-файлів. Кожен раз, коли ви знаходите цей підпис (або сигнатуру), ви можете відкрити новий файл для запису і починати заповнювати його байтами з моєї карти пам’яті, закриваючи цей файл тоді, коли знайдеться наступний підпис (сигнатура). Більше того, замість того, щоб читати по одному байту за раз, ви можете прочитати в буфер 512 байт за раз у цілях ефективності. Завдяки файловій системі FAT, ви з впевненістю можете знати, що підписи JPEG-файлів будуть вирівняними по блокам. Тобто, вам потрібно шукати ці підписи тільки в чотирьох перших байтах блока.

Усвідомте, звичайно, що JPEG-файл може охоплювати суміжні блоки. В іншому випадку, жоден JPEG-файл не міг би бути більше, ніж 512 байт. Може бути так, що останній байт JPEG-файлу не припаде на кінець блоку через про можливість провисання простору. Але не хвилюйтеся. Оскільки ця карта пам’яті була абсолютно нова, коли я почав створювати фотографії, карта була "занулена" (тобто заповнена 0) виробником; в цьому випадку будь-яке провисання простору буде заповнено нулями. Нічого страшного, якщо ці нулі є закінченням JPEG-файлу, який ви відновлюєте; ці файли як і раніше будуть доступними для перегляду.

У мене є лише одна карта пам'яті, але вас так багато! І тому я  зробив "судовий знімок" карти пам’яті, зберігаючи її вміст, байт за байтом, у файлі з ім'ям `card.raw`. Для того, щоб вам не доведелося витрачати час, перебираючи мільйони зайвих нулів, я зробив знімок тільки перших кількох мегабайт карти пам'яті. Але ви повинні в кінцевому підсумку знайти 50 JPEG-зображень.

### Набір файлів для лабораторної роботи

#### Завантаження

```bash
$ mkdir recover
$ cd recover
$ wget http://cdn.cs50.net/2017/fall/psets/4/recover/card.raw
$ ls
card.raw
```

### Специфікація

Реалізуйте програму `recover`, яка відновлює JPEG-зображення із "судового знімку".

* Реалізуйте вашу програму у файлі `recover.c`, що має знаходитись у папці `recover`.

* Ваша програма повинна приймати рівно один аргумент командного рядка - назву файлу "судового знімку", з якого потрібно відновити зображення. Якщо ця умова не виконуються, програма повинна нагадати користувачу про те, як її коректно використовувати за допомогою `fprintf` (до `stderr`), а `main` повинен повернути `1`. 

* Якщо файл із "судовим зображенням" не може бути відкритий, ваша програма повинна повідомити про це користувача за допомогою `fprintf` (до `stderr`). `main` у цьому випадку повинен повернути `2`.

* Якщо ваша програма використовує `malloc`, вона не повинна мати витоків пам'яті (memory leaks).

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?v=hOWYGowwId0)

### Використання вашої програми

Ваша програма повинна поводитись, як вказано у прикладах.

```bash
$ ./recover
Usage: ./recover image
$ echo $?
1
```

```bash
$ ./recover card.raw
$ echo $?
0
```

### Тестування

#### Коректніcть

```bash
check50 cs50/2018/x/recover
```

#### Стиль

```bash
style50 recover.c
```

### Розв'язок працівників CS50

Нажаль, доступність розв'язку працівників CS50 зіпсує вам задоволення від розв'язання цієї задачі!

### Підказки

Скоріще за все вам потрібно почати із створення файлу `recover.c` (у тій же папці, де знаходиться `card.raw`). Вам не портрібна бібліотека CS50, але вам потрібно визначити `main` таким чином, щоб він підтримував аргументи командного рядка. (Пам'ятаєте, як це зробити?)

Майте на увазі, що якщо `argv[1]` існує, ви можете відкрити `card.raw` програмно наступним чином:

```C
FILE *file = fopen(argv[1], "r");
```

Коли ваща програма виконується, вона повинна відновити кожен JPEG із `card.raw` і зберегти їх як окремі файли у вашій поточній робочій папці. Ваша програма повинна пронумерувати файли, які є результатом її роботи, надавши їм ім'я у формі `###.jpg`, де `###` - десяткове число із трьох розрядів - від `000` і далі. (Подружіться із [`sprintf`](https://reference.cs50.net/stdio/sprintf)). Вам не потрібно пробувати відновити початкові імена JPEG-файлів. Для того, щоб перевірити, чи JPEG-файли, які виводить ваша програма, є правильними, просто клікніть на них двічі і погляньте на них! Якщо всі фото виглядають непошкодженими, скоріше за все, ваша операція по відновленню була успішною!

Є ймовірність, що JPEG-файли, які видасть ваша програма після перших запусків, не будуть правильними. (Якщо ви відкриваєте їх і нічого не бачите, вони, скоріше за все, не є правильними!) Виконайте наступну команду, щоб видалити усі JPEG-файли у вашій попточній папці:

```bash
rm *.jpg
```

Якщо ви не хочете підтверджувати кожне видалення, замість команди вище виконайте таку команду:

```bash
rm -f *.jpg
```

Будьте обережні із прапорцем `-f`, так як він призводить до видалення без підтвердження користувача.