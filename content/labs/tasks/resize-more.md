# Resize (more)

### Вступ

Переконайтесь, що ви знайомі із структурою 24-бітного не стиснутого BMP, що описана у задачі [Whodunit](whodunit.md).

### Набір файлів для лабораторної роботи

#### Завантаження

```bash
$ wget http://cdn.cs50.net/2017/fall/psets/4/resize.zip
$ unzip resize.zip
$ rm resize.zip
$ cd resize
$ ls
bmp.h  copy.c  large.bmp  small.bmp  smiley.bmp
```

### Специфікація

Реалізуйте програму, що називається `resize`, яка змінює (тобто збільшує чи зменшує) розмір 24-бітного не стиснутого BMP у `f` разів. 

* Реалізуйте вашу програму у файлі `resize.c`, що має знаходитись у папці `resize`.

* Ваша програма повинна приймати рівно три аргументи командного рядка, а саме

    * перший з них (`f`) має бути числом з плаваючою комою, що належить проміжку (0.0; 100],
    
    * другий з них має бути ім'ям файлу, розмір якого потрібно змінити,
    
    * третій з них має бути ім'ям файлу, куди буде записано версію файлу зі зміненим розміром
    
* Якщо ці умови не виконуються, програма повинна нагадати користувачу про те, як її коректно використовувати за допомогою `fprintf` (до `stderr`), а `main` повинен повернути `1`. 

* Якщо ваша програма використовує `malloc`, вона не повинна мати витоків пам'яті (memory leaks)

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?v=iv9cw-PTSnA)

### Використання вашої програми

Ваша програма повинна поводитись, як вказано у прикладах.

```bash
$ ./resize
Usage: ./resize f infile outfile
$ echo $?
1
```

```bash
$ ./resize .5 large.bmp smaller.bmp
$ echo $?
0
```

```bash
$ ./resize 2 small.bmp larger.bmp
$ echo $?
0
```

### Підказки

Із такою програмою ми могли б створити `large.bmp` із `small.bmp` шляхом збільшення останнього у 4 рази (тобто помноживши і його ширину, і його висоту на 4) наведеною нижче командою:

```bash
./resize 4 small.bmp large.bmp
```

Пропонуємо вам знову розпочати із копіювання `copy.c` і перейменування його у `resize.c`. Але проведіть деякий час, думаючи, що означає змінити розмір BMP, особливо якщо f належить проміжку (0.0; 1.0). (Ви можете вважати, що `f` помножене на розмір вхідного файлу не перевищить 2<sup>32</sup> - 1. Якщо ж f дорівнює 1, вихідний файл повинен мати такі ж розміри, як і вхідний). Те, як поводитись із неточністю чисел із плаваючою комою та із округленням - вирішувати вам. Також пам'ятайте, що в деяких випадках втрата якості є невідворотньою. Вирішіть, які поля у `BITMAPFILEHEADER` та `BITMAPINFOHEADER` вам потрібно змінювати. Врахуйте те, що вам інколи потрібно (а інколи ні) додавати доповнення до рядків. Також переконайтесь, що ви підтримуєте значення `f` рівне `1` (в цьому випадку розмір вихідного і вхідного файлів мають співпадати).

Якщо ви використовуєте `malloc`, також використовуйте і `free` для того, щоб уникнути витоків пам'яті. Спробуйте використати `valgrind` щоб перевірити нявність витоків! 

### Тестування

Якщо ви хочете поглянути на заголовки, наприклад, файлу `large.bmp`, виконайте команду:

```bash
~cs50/hacker4/peek large.bmp
```

Навіть краще, якщо ви хочете порівняти заголовки вашого вихідного файлу із заголовками, які є результатом роботи програми працівників CS50, ви можете виконати такі команди (подумайте про те, що робить кожна із них)

```bash
./resize 4 small.bmp student.bmp
~cs50/hacker4/resize 4 small.bmp staff.bmp
~cs50/hacker4/peek student.bmp staff.bmp
```

#### Коректніcть

```bash
check50 cs50/2018/x/resize/more
```

#### Стиль

```bash
style50 resize.c
```

### Розв'язок працівників CS50

```bash
~cs50/hacker4/resize
```