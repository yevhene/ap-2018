# Cash

### Вступ

![Sorry, image not found](../resources/cash.png)

Коли ви використовуєте такий прилад, скоріше за все вам захочеться мінімізувати кількість монеток, яку ви видаєте кожному користувачу; інакше
ж вам прийдеться нажимати на важелі частіше ніж необхідно. На щастя, комп'ютерні науки надали можливість касирам по всьому світу можливість
мінімізувати цю кількість монеток: вони винайшли жадібні алгоритми.

Відповідно до National Institute of Standards and Technology (NIST), жадібний алгоритм це такий алгоритм, який "завжди обирає найкраший саме
зараз чи найкращий локальний розв'язок під час пошуку відповіді. Жадібні алгоритми знаходять глобально-оптимальний розв'язок для деяких задач,
але можуть знайти не оптимальний розв'язок для деяких інших задач".

Що все це означає? Припустимо, що касир має видати клієнту здачу, і в нього є пристрій, що видає монети у 25, 10, 5 та 1 центи. Для того,
щоб розв'язати цю "задачу", касирові необхідно один чи декілька разів натиснути на важелі. "Жадібний" касир із кожним натисканням захоче
забрати із потрібної суми максимально можливий обсяг. Наприклад, якщо він винний якомусь клієнтові 41 цент, найбільший (тобто локально-оптимальний)
обсяг цієї суми, який можна покрити одним натисканням - це 25 центів (ця сума є 
"найкращою", тому що вона приводить нас ближче до суми 0 центів швидше ніж всі інші монетки). Помітимо, що після цієї дії нам тепер потрібно видати
не 41 цент, а 16 центів (41 - 25 = 16). А отже, видання такого обсягу здачі - це схожа, але менша за попередню задача.
Зрозуміло, що видати ще 25 центів ми не можемо (ця сума буде занадто великою - касир не хоче втрачати гроші!), а отже наш жадібний касир
візьме монетку розміром 10 центів, що залишить його із задачею видачі здачі на 6 центів. На цьому етапі, жадібність змусить касира видати 
5 центів, а потім 1 цент, і після цього задача буде розв'язана. Клієнт отримає по одній монетці на 25, 10, 5 та 1 центи: 4 монетки загалом.

Виявляється, що такий жадібний підхід (тобто алгоритм) є не тільки локально-оптимальним, але і глобально-оптимальним для американських монеток
(а також для монеток Європейського Союзу) Тобто, якщо припустити, що у касира достатньо монеток, цей підхід "від більшого до меншого" приведе до
найменшої кількості виданих монеток. Скільки саме монеток буде видано для довільної задачі? Що ж, дізнатись це і є вашою задачею!

### Специфікація

* Напишіть програму, яка питатиме у користувача, скільки здачі необхідно видати, а потім видає мінімальну кількість монеток, за
допомогою яких цей обсяг здачі модна видати. Назвіть ваш файл `cash.c` і розмістіть його у папці
`~/workspace/pset1/cash/`

* Використовуйте функцію `get_float` із бібліотеки CS50 для того, щоб отримати обсяг здачі від користувача. Використовуйте `printf`
із бібліотеки стандартного вводу/виводу для того, щоб вивести ваш результат. Припускайте, що вам доступні монетки номіналом
25, 10, 5 та 1 центи

    * Ми просимо вас використовувати `get_float` для того, щоб ви могли працювати з доларами і центами, відкинувши знак долара (`$`).
    Іншими словами, якщо деякому клієнтові винні $9.75 (наприклад, газета коштувала 25 центів, але клієнт платить 10-доларовою купюрою),
    припускайте, що на вхід вашій програмі поступить величина 9.75, а не $9.75 чи 975. Якщо деякому клієнтові винні 9 доларів рівно,
    припускайте, що на вхід вашій програмі поступить величина 9.00 чи 9, але, знову ж таки, не $9 чи 900. Звичайно, через природу
    чисел з плаваючою комою, ваша програма скоріше за все коректно спрацює із входом 9.0 та 9.000; але вам не потрібно хвилюватись
    про перевірку того, чи ввід користувача є відформатованим так, як має бути відформатований грошовий ввід

* Вам не потрібно перевіряти, чи вміщаються користувацькі дані у тип даних float. Використання get_float перевірить, чи є вхідні дані
дробовими (або ж цілими, що також допустимо для нашої задачі), але не перевірить, чи є вони невід'ємними.

* Якщо користувач не вводить невід'ємну суму, ви повинні знову і знову просити його ввести коректну суму до тих пір, поки це не станеться.

* Користувач буде вводити лише одне число - суму здачі, яку необхідно видати. 
Ми просимо вас вивести лише одне число: мінімальну кількість монеток, після якої вивести `\n`

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?v=6w7Tws0seJk)

### Використання вашої програми

Ваша програма повинна поводитись, як вказано у прикладах.

``` bash
$ ./cash
Change owed: 0.41
4
```

``` bash
$ ./cash
Change owed: -0.41
Change owed: -0.41
Change owed: foo
Change owed: 0.41
4
```

### Тестування

#### Коректність

``` bash
check50 cs50/2018/x/cash
```

#### Стиль

``` bash
style50 cash.c
```

### Розв'язок працівників CS50

``` bash
~cs50/pset1/cash
```

### Підказки

* Як вказує останній пункт специфікації, не забудьте вивести символ нового рядка після виведення відповіді!

* Остерігайтесь вбудованої неточності чисел з плаваючою комою. Наприклад, число 0.1 не може бути представлено точно змінною типу
`float`. Спробуйте вивести його значення, скажімо, до 55-го десяткового знаку наступним кодом:

``` C
float f = 0.1;
printf("%.55f\n", f);
```

А отже, перед тим, як робити зміни до суми, вам, мабуть, варто конвертувати всю суму до центів (тобто до цілого числа) для того, щоб уникнути
незначних помилок, що можуть накопичуватись! Звичайно ж, не варто просто змінювати тип даних вводу із `float` на `int`! Подумайте: скільки центів
в одному доларі?

* Також пам'ятайте, що вам необхідно округлювати суму у центах (до найближчого центу). Не обрізайте (тобто не використовуйте функію `floor`) 
отриману вами суму у центах!




