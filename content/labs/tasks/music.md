# Music

### Вступ

Пісня - це насправді всього лиш послідовність звуків, які також відомі як ноти, кожна з яких має деяку тривалість. У Західній музиці, кожна з цих нот позначається буквою, від A до G. Ці букви відповідають білим клавішам на фортепіано, як це показано на рисунку.

![Ноти](../resources/music-notes-1.png)

Серед білих клавіш знаходяться чорні клавіші, кожна з яких ідентифікується своєю близькістю до білої клавіші, як це показано на рисунку. Чорна клавіша, що знаходиться одразу над (тобто справа від) білої клавіші, ідентифікується тією ж самою буквою, але із суфіксом ♯ (його часто позначають як #), також відомим як дієз; чорна клавіша, що знаходиться одразу під (тобто зліва від) білої клавіші, також позначається тією ж буквою, але із суфіксом ♭ (його часто позначають як b), також відомим як бемоль. Кожна клавіша на фортепіано (не важливо, біла чи чорна), знаходиться на відстані одного напівтона (напівкрока) від свого сусіда. Ефект від # чи b (також відомими як альтераційні знаки) полягає у тому, щоб відповідно підвищити чи понизити висоту ноти на одну напівноту.

![Фортепіано](../resources/music-piano-1.png)

Фортепіано зазвичай мають 88 клавіш, 52 з яких - білі. Так як існує лише 7 букв (від A до G), якими їх ідентифікують, одна буква завжди позначає декілька клавіш. І тому ноти поділили на октави, групи послідовних клавіш, кожна з яких пронумерована, як показано на рисунку.

![Фортепіано](../resources/music-piano-2.png)

**Джерело:** [https://en.wikipedia.org/wiki/A440_(pitch_standard)](https://en.wikipedia.org/wiki/A440_(pitch_standard))

А отже, ноти ідентифікують не тільки буквами (і знаками альтерації), але також і номером октави, як показано на рисунку.

![Фортепіано](../resources/music-piano-3.png)

Коли ми натискаємо на клавіші, вони генерують вібрації і, у свою чергу, хвилі молекул повітря (тобто чергування високого і низького повітряного тиску), також відомих як звукові хвилі (див. рисунок). Коли ці звукові хвилі потрапляють до вашого вуха, ви чуєте звук. Кожна з цих звукових хвиль подорожує на певній швидкості, також відомій як частота. Чим вищою є частота звукової хвилі, тим вищий звук ви почуєте; чим нижчою є ця частота, тим нижчий звук ви почуєте. Якщо вам цікаво, чому деякі молекули повітря звучать краще за інші, вам може сподобатись [магічна математика музики](https://plus.maths.org/content/magical-mathematics-music).

![Звукова хвиля](../resources/music-waves.png)
**Хронологічна послідовність зображень стискання молекул повітря від звкової хвилі, що рухається вправо. Джерело: [https://web.stanford.edu/~zhoufan/MathematicsOfMusic.pdf](https://web.stanford.edu/~zhoufan/MathematicsOfMusic.pdf)**

Однією з нот, інофрмацію про які вам варто занотувати (ха!), є середня нота C, позначена блакитним на одному з рисунків вище. Її також називають C4, так як це нота C 4-ої октави. Над середньою нотою C (тобто справа від неї), знаходиться ще одна варта нотифікації (ха!) нота, А4 - вона позначена жовтим на тому ж рисунку. Її ще називають A440, адже її частота слкладає 440 Hz. Це у свою чергу означає, що відповідна звукова хвиля коливається вверх і вниз 440 разів за секунду.

Частоти нот однієї октави відрізняються від частот нот сусідніх октав у 2 рази. Наприклад, частота ноти А3 складає 220 Hz (тобто половину частоти A4), а частота А5 складає 880 Hz (тобто вдвічі більше за частоту A4). Більш загально, частота, f, деякої ноти складає 2<sup>n/12</sup> × 440, де n - кількість напівтонів між цією нотою і A4, причому n є від'ємним, якщо ця нота нижче (тобто зліва від) A4, і є додатнім, коли ця нота вище (тобто справа від) А4. 

Музиканти, зазвичай, записують музику не за допомогою букв чи частот, а за допомогою візуальної нотації, також відомої як партитура. Всі ноти записуються на та поміж лініями, також відомим як нотний стан, причому всі знаки альтерації записуються зліва від відповідної ноти. Лінії, на чи поміж якими записані ноти показують букву та октаву ноти, як це зображено на рисунку.

![Партитура](../resources/music-sheet.png)

В той же час, тривалість ноти показується за допомогою її форми. Наприклад,

* &#9834; позначає одну восьму ноти. Коли декілька таких нот знаходяться поруч, їх часто об'єднують у символ &#9835;

* &#9833; позначає одну четверту ноти, і її тривалість вдвічі більша за тривалість однієї восьмої ноти.

* &#9833;. позначає одну четверту ноти із крапкою, і її тривалість втричі більша за тривалість однієї восьмої ноти.

* &#119134; позначає половину ноти, і її тривалість в чотири рази більша за тривалість однієї восьмої ноти.

* &#119133; позначає цілу ноту, і її тривалість у вісім раз більша за тривалість однієї восьмої ноти.

Відсутність ноти (тобто тиша) називається паузою, і її довжина також показується за допомогою її форми. Наприклад,

* &#119102; позначає одну восьму паузи, і ця довжина рівна довжині однієї восьмої ноти.

* &#119101; позначає одну четверту паузи, і її довжина вдвічі більша за довжину однієї восьмої паузи.

* &#119100; позначає одну другу паузи, і її довжина в чотири рази більша за довжину однієї восьмої паузи.

* &#119099; позначає цілу паузу, і її довжина у вісім раз більша за довжину однієї восьмої паузи.

Використовуючи ці будівельні блоки, пісню можна представити таким чином:

![Партитура Happy birthday](../resources/music-happy-birthday-sheet.png)

Якщо вам не знайома ця пісня, [ось як вона звучить](https://docs.cs50.net/2018/x/psets/3/music/bday.wav), коли звукові хвилі, які створюють ноти, досягають ваших вух.

### Набір файлів для лабораторної роботи

Частиною цієї задачі є набір файлів, які створили працівники CS50. Перед тим, як внести свій вклад, вам потрібно прочитати (і зрозуміти!) ці файли. Існує набір файлів заголовків, що ви вже використовуєте протягом деякого часу (`cs50.h`, `stdio.h` тощо). Ці файли "живуть" всередині IDE CS50. На відміну від них, файли, які ми вам надаємо, будуть "жити" поряд із вашим кодом. Таким чином, вам буде легше їх побачити.

#### Завантаження

Ось як ви можете завантажити ці файли.

Спочатку виконайте наступну команду:

```bash
cd ~/workspace/pset3/
```

Таким чином, ви перейдете до папки `~/workspace/pset3/`. Після цього, виконайте наступну команду:

```bash
wget http://cdn.cs50.net/2017/fall/psets/3/music.zip
```

Таким чином ви завантажете необхідні файли як ZIP архів. Якщо ви зараз виконаєте команду `ls`, ви маєте побачити файл `music.zip` всередині вашої папки `pset3`. Для того, щоб розархівувати ці файли, виконайте наступну команду: 

```bash
unzip music.zip
```

а після цього - команду

```bash
rm music.zip
```

Таким чином ви розархівуєте всі необхідні файли та видалите файл архіву. Якщо ви виконаєте команду `ls`, ви повинні побачити папку з назвою `music` всередині папки `pset3`. Виконайте команду:

```bash
cd music/
```

Таким чином ви перейдете у цю папку. Виконайте команду `ls`. Ви повинні побачити файли і папку, що наведені нижче. Вони і є тим набором файлів, які вам необхідні!

```bash
Makefile  helpers.c  helpers.h  notes.c  synthesize.c  songs/  wav.c  wav.h
```

#### Розуміння наданих файлів

Давайте прочитаємо ці файли для того, щоб зрозуміти їх. У майбутньому, читання (і розуміння!) коду інших людей, коду сторонніх бібліотек, часто буде вашим першим кроком у розв'язанні задачі. Таким чином, ви можете спиратися на роботу інших програмістів, і, завдяки цьому, розв'язувати навіть більш цікаві задачі!

#### `songs/`

Для початку, відкрийте папку `songs/`, за допомогою команди `cd` чи за допомогою переглядача файлів CS50 IDE. У цій папці знаходяться декілька файлів `.txt`, всередині кожного з яких, як виявляється, знаходиться пісня! Так як ASCII не придатний для того, щоб відобразити партитуру, працівники CS50 переробили представлення пісень таким чином, щоб комп'ютер їх міг розуміти. У кожній лінії файлу знаходиться опис ноти і її тривалості, розділені символом `@`. Наприклад, згори файлу `jeopardy.txt` (який ми вам пропонуємо відкрити), знаходяться наступні рядки:

```
G4@1/4
C5@1/4
G4@1/4
C4@1/4
G4@1/4
C5@1/4
G4@1/4
```

Перша нота вступної пісні Jeopardy має тривалість 1/4 і є нотою G четвертої октави (Jeopardy - інтелектуальна гра на американському телебаченні; аналог на російському телебаченні - "Своя гра" - примітка перекладача). Друга нота має таку ж тривалість, але є нотою C п'ятої октави (тобто знаходиться на декілька клавіш правіше на фортепіано). Після неї йдуть ще п'ять нот з такою тривалістю. 

Під цими сімома рядками у jeopardy.txt знаходяться два пустих рядки. Це означає, що після сьомої ноти слідують дві паузи довжиною 1/8 (що еквівалентно одній паузі довжини 1/4).  Після цих пауз, знову починає грати музика (із ще однією паузою через декілька нот).

Зрозуміло? Перегляньте ще декілька інших `.txt` файлів у папці `songs`. Хоча рядки цих файлів на перший погляд виглядають наче шифр, вони на справді є всього лиш перекладом красивішої партитури у формат, що може зрозуміти комп'ютер. Коли ми говоримо про формат, що може зрозуміти комп'ютер, ми маємо на увазі, що скоро ви напишете код, який зчитує ці ноти і їх тривалості!

#### `notes.c`

Далі відкрийте файл `notes.c`. У цьому файлі знаходиться програма (яку ми називатимемо `notes`), яка не тільки друкує на екран частоти (у Гц) всіх нот в октаві, але й створює WAV файл (аудіо файл), за допомогою якого ви можете почути ці ноти. За замовчуванням, програма працює із четвертою октавою, але якщо ви передасте їй аргумент командного рядка (ціле число від 0 до 8 включно), ви зможете побачити і почути частоти нот будь якої октави.

Прочитайте код і коментарі у файлі `notes.c` і постарайтесь зрозуміти більшість (а може і всі), рядки коду. Деякі з них можуть виглядати незнайомо. Наприклад, за конвенцією (мається на увазі, що така практика є загальноприйнятою серед програмістів), цей код використовує функцію `fprintf` для того, щоб вивести повідомлення про помилку до `stderr` (standard error) замість `printf`, який, як виявляється, виводить свої повідомлення до `stdout` (standard output). За замовчуванням і повідомлення, які виводяться до `stdout`, і повідомлення, які виводяться до `stderr`, з'являються на екрані користувача. Але їх можна розділити під час виконання програми, і це дасть змогу користувачу відрізняти повідомлення про помилку від решти повідомлень. Трошки більше про це ми розкажемо у майбутніх роботах.

Також зверніть увагу, що функція `main` повертає `1` у випадку помилки. Це також робиться відповідно до конвенції. До цього часу ми не повертали ніяких значень із `main`. Але пригадайте, що весь цей час main мав тип даних, яикй він має повернути, а саме `int`. Виявляється, що коли `main` закінчує своє виконання, він за замовчуванням повертає `0`, що, за конвенцією, означає успіх. Якщо ж щось йде не так, за конвенцією слід повернути значення, відмінне від `0` (наприклад `1`). Це значення називають "кодом виходу", і воно може бути використано щоб розрізняти один тип помилки від іншого. Насправді, якщо ви колись бачили загадковий код помилки на екрані вашого комп'ютера, це цілком могло бути значення, яке повернула функція main програми, що ви використовували в той момент.

Також зверніть увагу, що ця програма використовує функцію `sprintf`, яка, замість того, щоб друкувати на екран, зберігає свої вихідні дані у рядку (звідси і `s` у `sprintf` - string printf). Ми використовуємо її щоб створити рядок із двох підстановок, `%s` та `%i`. Зверніть увагу на те, як ми виділяємо місце для (короткого) рядка шляхом визначення масива на 4 символи. Далі ми використовємо `sprintf` щоб зберегти `NOTES[i]` (рядок, звідси і `%s`) та `octave` (ціле число, звідси і `%i`) у цій виділеній пам'яті. Таким чином ми можемо взяти значення як, наприклад `"A"` та `4` і, фактично, об'єднати їх (тобто дописати другу частину до першої) для того, щоб створити новий рядок (наприклад, `"A4"`).

Також у цій програм ми викликаємо (можливо) незнайомі нам функції `song_open`, `frequency`, `note_write` і `song_close`. Виявляється, що ці функції реалізовані у інших файлах, що ми вам надали. Слідкуйте за ними!

#### `synthesize.c`

У цьому файлі знаходиться програма (яку ми називатимемо `synthesize`), що синтезує (тобто генерує) пісню із послідовності нот. Зверніть увагу на те, як вона отримує ноти від користувача одну за одною, використовуючи `get_string`. Cпочатку вона перевіряє, чи не є вхідні дані користувача паузою, що трапилось би у випадку, якби користувач просто натиснув Enter. Інакше ж вона розбиває вхідні дані на дві частини: ноту, яку можна знайти зліва від `@`, та дріб (що позначає тривалість ноти), який можна знайти справа від `@`. Для цього використовується функція `strtok`. Після цього програма записує ноту (чи паузу) до файлу.

#### `wav.h`

Далі відкрийте файл `wav.h`, файл заголовків, який використовують `notes.c` та `synthesize.c`. Цей файл, разом із `wav.c` представляє собою не програму, а бібліотеку - набір функцій, які можуть використовувати інші програми у якості будівельних блоків. Так само, `cs50` та `stdio` є бібліотеками. Відмінність полягає у тому, що код цієї бібліотеки живе у вашому робочому просторі.

У файлі `wav.h` присутні визначення двох нових типів даних: один називається `note`, а інший - `song`. Але більше про це (і про ключові слова на зразок `typedef` і `struct`) ми поговоримо пізніше. Зараз лише зверніть увагу, як цей файл визначає 4 функції (`note_write`, `rest_write`, `song_close`, and `song_open`), які використовують `notes` та `synthesize`.

#### `wav.c`

В той же час у `wav.c` знаходяться справжні реалізації цих функцій та декількох інших. Дійсно, цей файл містить у собі функції, що реалізують підтримку WAV файлів, популярного формату аудіо файлів. Ці функції дозволяють `notes` та `synthesize` зберігати ноти на диск у файлах із розширенням `.wav`. Для того, щоб послухати ці файли, просто відкрийте їх у переглядачі файлів CS50 IDE. Або ж ви можете завантажити їх на ваш комп'ютер та послухати їх локально.

Немає потреби розуміти весь код у `wav.c`, але ми запрошуємо вас прочитати цей код якщо у вас є таке бажання!

#### `Makefile`

Далі відкрийте `Makefile`, формат якого, скоріше за все, відрізняється від усього що ви бачили до цього. Як і натякає назва цього файлу, він є спорідненим до `make`, програми, яку ви,мабуть, використовували щоб скомпілювати більшість ваших програм, так як компілювання із `clang` зазвичай вимагає більшої кількості натискань на клавіші. У попередніх задачах нам не був потрібен `Makefile`, який, насправді, є конфігураційним файлом для `make`, так як `make` міг зрозуміти, як компілювати програму, що складається з одного файла (наприклад, `hello.c`). Але компіляція `notes` та `synthesize` вимагає компіляції декількох файлів, адже обидві ці програми покладаються на `wav.h` та `wav.c`, а також на два інших файли, `helpers.h` і `helpers.c`.

Просте виконання

```bash
make notes
```

чи

```bash
make synthesize
```

не надало б `make` достатньо інформації щоб зрозуміти, які файли йому потрібні. `Makefile` існує, щоб `make` знав, як скомпілювати ці програми.

#### `helpers.h`

У цьому файлі присутні визначення трьох функцій:

- `duration`, яка приймає у якості вхідних даних дріб у вигляді рядка (наприклад, `1/4`) і повертає `int`, що відповідає кількості 1/8-их у цьому дробові (у нашому випадку `2`, так як `1/4` = `2/8`)

- `frequency`, яка приймає у якості вхідних даних рядок відформатований як
  - `XY` (наприклад, `A4`), де `Х` - будь-яка буква від `A до G`, а `Y` - будь-яка цифра від `0` до `8` чи
  - `XYZ` (наприклад, `A#4`), де `Х` - будь-яка буква від `A` до `G`, `Y` - `#` або `b`, і `Z` - будь-яка цифра від `0` до `8`,

  і повертає ціле число, частоту ноти, округлену до найближчого цілого.

- `is_rest`, що повертає `true`, якщо його вхідні дані (рядок) представляють собою паузу у описаному вище представленні; інакше функція має повернути `false`.

#### `helpers.c`

У цьому файлі мають бути реалізації цих трьох функцій, але ні! Поки що ні. Саме ви маєте їх реалізувати!

### Специфікація

#### `bday.txt`

У файлі `bday.txt` наберіть ASCII представлення пісні *Happy Birthday*, переклавши її партитуру, що надана вище, до вигляду, з яким може працювати комп'ютер (також описаний вище). Ваша пісня повинна розпочинатись з:

```
D4@1/8
D4@1/8
E4@1/4
D4@1/4
G4@1/4
F#4@1/2
```

#### `helpers.c`

#### `is_rest`

Завершіть реалізацію `is_rest` у `helpers.c`. Пригадайте, що паузи позначаються пустими рядками у нашому форматі. І пригадайте, що `synthesize` викликає цю функцію для того, щоб визначити, чи рядок, який ввів користувач дійсно є позначає паузу.

Як визначити, чи рядок пустий? Для того, щоб відповісти на це запитання, спочатку подивіться на код `cs50.h`, де задокументована функція `get_string`.

https://github.com/cs50/libcs50/blob/develop/src/cs50.h

Що говорять коментарі згори від `get_string` про те, що повертає функція якщо користувач просто натискає Enter, таким чином вводячи лише символ переведення рядка (тобто `\n`)?

Коли такий рядок передається до `is_rest`, як ця функція (ні, ви!) маєте це розпізнати?

#### `duration`

Завершіть реалізацію `duration` у `helpers.c`. Пригадайте, що функція має приймати у якості вхідних даних рядок, що представляє собою дріб, і конвертувати його у цілу кількість 1/8-их. Ви можете припустити, що цей рядок буде відформатовано у вигляді `X/Y`, де `X` і `Y` - додатні десяткові цифри, а `Y`, до того ж, є степеню числа 2.

#### `frequency`

Нарешті, завершіть реалізацію `frequency` у `helpers.c`. Пригадайте, що ця функція має приймати у якості вхідних даних рядок, що позначає ноту (наприклад `A4`) і повертати відповідну їй частоту у герцах як ціле число.

Також пригадайте:

1. Частота, `f`, деякої ноти складє 2<sup>n/12</sup> × 440, де `n` - кількість напівтонів між цією нотою і `A4`.

2. Кожна клавіша на фортепіано знаходиться на відстані одного напівтону (чи напівкроку) від сусідньої клавіші, не важливо - білої чи чорної.

3. Ефект `#` і `b`, також відомих як альтераційні знаки, полягає у підвищенні чи пониженні, відповідно, висоти ноти на один напівтон.

Під час реалізації цієї функції вам можуть знадобитись функції `pow` і `round`, визначені у `math.h`.

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?list=PLhQjrBD2T380boRF-5b7Dow2opWBbZhLH&v=PwrtaYvm1K0)

### Тестування

Для того, щоб скомпілювати `notes` та `synthesize`, виконайте

```bash
make
```

Це скомпілює обидва файли при умові, що у `helpers.c` відсутні синтаксичні помилки.

Для того, щоб перевірити вашу реалізацію `frequency` у `helpers.c`, виконайте `notes`, яка викликає як раз цю функцію, наступним чином:

```bash
./notes
```

Переконайтесь, що виведені частоти відповідають вашим підрахункам (на папері чи калькуляторі). Ви також можете послухати файл `notes.wav`, і, якщо у вас є музичний слух, перевірити результат таким чином. Перевірте інші октави, вказавши їх номер як аргумент командного рядка:

```bash
./notes 5
```

Для того, щоб краще протестувати `frequency` разом із `is_rest` та `duration`, виконайте `synthesize`

```bash
./synthesize test.wav
```

Далі введіть одну або декілька нот, по одній ноті в рядок. Коли ви закінчете вводити ноти, натисніть `ctrl-d`, щоб надіслати сигнал `EOF` ("end of file" - кінець файлу) до `get_string`, щоб він вийшов із циклу у програмі. Відкрийте результуючий файл (тобто `test.wav`) виконавши

```bash
open test.wav
```

чи двічі натиснувши на `test.wav` у переглядачі файлів CS50 IDE. Послухайте пісню щоб побачити (ну добре, почути), чи вона звучить, як, на вашу думку, вона повинна звучати!

**Не забудьте обирати різне ім'я для кожного WAV-файлу, що ви синтезуєте. Інакше ваш браузер може закешувати (запам'ятати) і зіграти стару версію заново згенерованого WAV файлу.**

Набирання нот швидко може стати нудним. Тому ви замість цього можете скористатись "перенаправленням вхідних даних" для того, щоб передавати цілі файли як вхідні дані для `synthesize`. Наприклад, щоб передати усі ноти файла `jeopardy.txt` до `synthesize`, виконайте команду:

```bash
./synthesize jeopardy.wav < songs/jeopardy.txt
```

Потім виконайте

```bash
open jeopardy.wav
```

чи просто двічі натисніть на `jeopardy.wav` у переглядачі файлів CS50 IDE. Таким чином ви відкриєте і послухаєте (при умові, що у вас немає помилок!) згенеровану пісню.

#### Коректність

```bash
check50 cs50/2018/x/music
```

#### Стиль

```bash
style50 helpers.c
```

### Підказки

Як завжди, коли ви пишете код, робіть маленькі кроки, імплементуючи мінімальну кількість рядків, після якої ви можете перевірити свій прогрес і виправити можливі помилки. Тільки коли цей крок виконано (тобто помилок немає!) ви повинні приступати до наступного. Ви можете планувати ваші кроки написавши пвсевдокод до того, як почнете писати код.

У контексті `frequency`, ваші кроки можуть бути такими:

1. Спочатку реалізуйте підтримку тільки для нот `A0`, `A1` ... `A8`. Переконайтесь, що частоти, які повертає `frequency`, співпадають з реальними значеннями. Ви це можете зробити, виконавши `notes`, або використовуючи `debug50` чи `eprintf`. Порівняйте вихідні дані вашої функції із вашими підрахунками на папері чи калькуляторі.

2. Далі додайте підтримку для `#` і `b`, але знову ж таки для вищезазначених нот (тобто для `A#0`, `A#1` ... `A#8` і `Ab0`, `Ab1` ... `Ab8`)

3. Далі додайте підтримку для нот `B`. Далі - для нот `C`. Далі - для решти нот.

