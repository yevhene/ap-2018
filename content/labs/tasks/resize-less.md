# Resize (less)

### Вступ

Переконайтесь, що ви знайомі із структурою 24-бітного не стиснутого BMP, що описана у задачі [Whodunit](whodunit.md).

### Набір файлів для лабораторної роботи

#### Завантаження

```bash
$ wget http://cdn.cs50.net/2017/fall/psets/4/resize.zip
$ unzip resize.zip
$ rm resize.zip
$ cd resize
$ ls
bmp.h  copy.c  large.bmp  small.bmp  smiley.bmp
```

### Специфікація

Реалізуйте програму, що називається `resize`, яка змінює (тобто збільшує) розмір 24-бітного не стиснутого BMP у `n` разів. 

* Реалізуйте вашу програму у файлі `resize.c`, що має знаходитись у папці `resize`.

* Ваша програма повинна приймати рівно три аргументи командного рядка, а саме

    * перший з них (`n`) має бути додатнім цілим числом, що не перевищує `100`,
    
    * другий з них має бути ім'ям файлу, розмір якого потрібно змінити,
    
    * третій з них має бути ім'ям файлу, куди буде записано версію файлу зі зміненим розміром
    
* Якщо ці умови не виконуються, програма повинна нагадати користувачу про те, як її коректно використовувати за допомогою `fprintf` (до `stderr`), а `main` повинен повернути `1`. 

* Якщо ваша програма використовує `malloc`, вона не повинна мати витоків пам'яті (memory leaks)

### Відеоінструкція

[Посилання на YouTube](https://www.youtube.com/watch?v=zOylgRdzv_U)

### Використання вашої програми

Ваша програма повинна поводитись, як вказано у прикладах.

```bash
$ ./resize
Usage: ./resize n infile outfile
$ echo $?
1
```

```bash
$ ./resize 2 small.bmp larger.bmp
$ echo $?
0
```

### Підказки

Із такою програмою ми могли б створити `large.bmp` із `small.bmp` шляхом збільшення останнього у 4 рази (тобто помноживши і його ширину, і його висоту на 4) наведеною нижче командою:

```bash
./resize 4 small.bmp large.bmp
```

Пропонуємо вам знову розпочати із копіювання `copy.c` і перейменування його у `resize.c`. Але проведіть деякий час, думаючи, що означає змінити розмір BMP. (Ви можете вважати, що `n` помножене на розмір вхідного файлу не перевищить 2<sup>32</sup> - 1). Вирішіть, які поля у `BITMAPFILEHEADER` та `BITMAPINFOHEADER` вам потрібно змінювати. Врахуйте те, що вам інколи потрібно (а інколи ні) додавати доповнення до рядків. Також переконайтесь, що ви підтримуєте значення `n` рівне `1` (в цьому випадку розмір вихідного і вхідного файлів мають співпадати).

Якщо ви використовуєте `malloc`, також використовуйте і `free` для того, щоб уникнути витоків пам'яті. Спробуйте використати `valgrind` щоб перевірити нявність витоків! 

### Тестування

Якщо ви хочете поглянути на заголовки, наприклад, файлу `large.bmp`, виконайте команду:

```bash
~cs50/pset4/peek large.bmp
```

Навіть краще, якщо ви хочете порівняти заголовки вашого вихідного файлу із заголовками, які є результатом роботи програми працівників CS50, ви можете виконати такі команди (подумайте про те, що робить кожна із них)

```bash
./resize 4 small.bmp student.bmp
~cs50/pset4/resize 4 small.bmp staff.bmp
~cs50/pset4/peek student.bmp staff.bmp
```

#### Коректніcть

```bash
check50 cs50/2018/x/resize/less
```

#### Стиль

```bash
style50 resize.c
```

### Розв'язок працівників CS50

```bash
~cs50/pset4/resize
```